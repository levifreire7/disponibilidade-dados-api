# Disponibilidade de Dados via API Privada com Google Cloud Run
## Tarefa 1: Evolução
1. Replique o projeto que construímos mas solicitamos que realize algumas melhorias.
Arrume o bug do código para nos dados fictícios referente ao estado, de fato carregar corretamente a sigla. Investigue a possível causa disso (uma sugestão talvez seja checar o método que é utilizado):
**Resolução:** Utilizei o método state_abbr da lib Faker, que retorna a sigla de duas letras dos estados.
No método em que passamos o cd_customer, em vez de passarmos pela URL (parâmetro de caminho - path param), uma boa prática é colocar essa passagem de dados por meio do header da requisição (em alguns casos, pelo body também). Mas como estamos referindo a um dado sensível (que é o CPF criptografado), por mais que ele esteja criptografado, é comum passarmos essa informação por cabeçalho (header) da requisição. Refatore esse método para passarmos o cd_customer por header da requisição.
**Resolução:** Utilizei a classe Header() do FastAPI seguindo a seguinte estrutura: cd_customer: Annotated[str, Header()]
2. Sugerimos você gerar uma segunda tabela fictícia, como simular possíveis compras efetuados pelos clientes que foram gerados no fluxo inicial. Para a tabela é esperado conter informações como o cd_customer (cliente que fez a compra), data em que o cliente fez a compra, nome do produto envolvido, quantos itens, valor unitário do produto, valor do frete e valor total da compra [(quantidade de itens x preço unitário) + frete]. As duas tabelas fictícias devem fazer sentido em conjunto, ou seja, na tabela compras teremos apenas clientes que estão na tabela de consumidores. Então considere isso no seu fluxo de população da tabela. Crie um método que por meio da passagem do cd_customer via header seja retornado o faturamento total referente aquele cliente, isto é, a soma de todas as compras que o cliente fez (sem incluir frete).
**Resolução:** Primeiramente eu criei uma nova tabela de nome 'sales' no banco de dados através do SQLAlchemy com as colunas sugeridas, incluindo a chave estrangeira para a tabela 'customers'. Em seguida populei a tabela com valores gerados através da biblioteca Faker e adaptei a função de popular a tabela 'customers' para retornar os ids gerados, desta forma consegui popular a nova tabela referenciando as chaves primárias da 'customers'.
Para o novo endpoint segui o exemplo do que já havia implementado, inclusive passando o id no header da requisição. Apenas ajustei a consulta ao banco para retornar a soma do total de todos os pedidos realizados por um determinado cliente.